"""Servo controller using gpiozero."""

from __future__ import annotations

import logging
import threading
import time
from dataclasses import dataclass
from typing import Optional

try:
    from gpiozero import Servo
except ImportError:  # pragma: no cover - development hosts
    Servo = None  # type: ignore


# gpiozero が利用できない環境向けのモックサーボクラス
class _MockServo:
    """Fallback servo used when gpiozero is unavailable."""

    def __init__(self) -> None:
        self.value: float = 0.0

    def detach(self) -> None:
        return


# gpiozero.Servo に渡す設定値をまとめたデータクラス
@dataclass(frozen=True)
class ServoConfig:
    pin: int
    min_pulse_width: float = 0.0005
    max_pulse_width: float = 0.0024
    locked_value: float = -1.0
    unlocked_value: float = 1.0
    movement_hold_time: float = 0.6
    initial_state: str = "locked"


class ServoController:
    """Manage the smart lock servo lifecycle."""

    def __init__(self, config: ServoConfig, dry_run: bool = False) -> None:
        # 設定値を保持しつつ、gpiozeroの利用可否からドライラン判定を行う
        self.config = config
        self.dry_run = dry_run or Servo is None
        self._state_lock = threading.Lock()
        self._state = config.initial_state
        self._servo: Optional[object] = None
        self._initialized = False

    def initialize(self) -> None:
        """Set up the servo device and move to the initial position."""

        # 初期化済みの場合は二重初期化を避ける
        if self._initialized:
            return
        if self.dry_run:
            logging.warning("Running in dry-run mode; gpiozero output is disabled")
            self._servo = _MockServo()
        else:
            if Servo is None:  # pragma: no cover - safety net
                raise RuntimeError("gpiozero is not available. Enable dry-run mode.")
            try:
                # パルス幅を指定して gpiozero.Servo を構築する
                servo = Servo(
                    self.config.pin,
                    min_pulse_width=self.config.min_pulse_width,
                    max_pulse_width=self.config.max_pulse_width,
                )
            except Exception as exc:  # pragma: no cover - hardware failure
                raise RuntimeError("Failed to initialise gpiozero.Servo") from exc
            self._servo = servo
        self._initialized = True
        # 要求された初期状態へサーボを移動させる
        self._set_state(self._state, force=True)

    def cleanup(self) -> None:
        # サーボを遊離させてから参照を破棄する
        if not self._initialized:
            return
        if self._servo is not None:
            with self._state_lock:
                self._detach()
        self._servo = None
        self._initialized = False

    @property
    def state(self) -> str:
        with self._state_lock:
            return self._state

    def lock(self) -> str:
        # 施錠状態へ移行させる
        return self._set_state("locked")

    def unlock(self) -> str:
        # 解錠状態へ移行させる
        return self._set_state("unlocked")

    def _set_state(self, target: str, *, force: bool = False) -> str:
        # サーボに与える値を決定し、状態を更新する
        if target not in {"locked", "unlocked"}:
            raise ValueError(f"Unsupported state: {target}")
        with self._state_lock:
            if not force and target == self._state:
                logging.debug("Servo already in %s state", target)
                return self._state
            value = (
                self.config.locked_value
                if target == "locked"
                else self.config.unlocked_value
            )
            self._drive(value)
            self._state = target
            logging.info("Servo state -> %s", self._state)
            return self._state

    def _drive(self, value: float) -> None:
        # gpiozero.Servo に値を与えて一定時間保持する
        hold = max(0.05, self.config.movement_hold_time)
        clamped = max(-1.0, min(value, 1.0))
        if self.dry_run:
            logging.info("Dry-run servo move to %.2f for %.2fs", clamped, hold)
            time.sleep(hold)
            return
        if self._servo is None:
            raise RuntimeError("Servo not initialised")
        assert hasattr(self._servo, "value")  # for type checking
        self._servo.value = clamped  # type: ignore[attr-defined]
        time.sleep(hold)
        self._detach()
        time.sleep(0.05)

    def _detach(self) -> None:
        # サーボをフロート状態に戻し発熱を抑える
        if self._servo is None:
            return
        detach = getattr(self._servo, "detach", None)
        if callable(detach):
            try:
                detach()
            except Exception:  # pragma: no cover - hardware cleanup
                logging.exception("Failed to detach servo")
